configfile: 'config.yaml'

RUN_NAMES = sorted(config['data'])
REFERNCE_TRANSCRIPTOME_SEQS = dict(config['reference_transcriptomes'])

rule all:
    input:
        'sequencing_summary.feather',
        expand('sequences/{name}.fa.gz', name=RUN_NAMES),
        expand('tables/controls-mapq-{name}.txt.gz', name=RUN_NAMES),
        expand('alignments/{name}-{refsample}.bam.bai', name=RUN_NAMES,
                refsample=sorted(REFERNCE_TRANSCRIPTOME_SEQS))

rule basecall:
    output: '{name}.albacore/.hyeseq_basecall_done'
    threads: 40
    run:
        input_dir = config['data'][wildcards.name]
        output_dir = os.path.dirname(output[0])
        shell('read_fast5_basecaller.py \
                --input "{input_dir}" \
                --resume --worker_threads {threads} \
                --save_path "{output_dir}" \
                --flowcell {config[flowcell]} --kit {config[kit]} \
                --disable_filtering --disable_pings --recursive \
                --files_per_batch_folder 1000 \
                --output_format fastq,fast5 \
                --reads_per_fastq_batch 1000')
        shell('touch {output}')

rule datadir_reorganize:
    input: '{name}.albacore/.hyeseq_basecall_done'
    output: '{name}/.hyeseq_reorganization_done', '{name}/sequences.fasta.gz'
    threads: 16
    shell: 'scripts/albacore_reorganize.py -o {wildcards.name} \
                -i {wildcards.name}.albacore -p {threads} \
            && touch {output}'

rule generate_catalog:
    input: expand('{name}/.hyeseq_reorganization_done', name=RUN_NAMES)
    output: 'sequencing_summary.feather'
    shell: 'scripts/generate_fast5_catalog.py {RUN_NAMES}'

rule generate_fasta:
    input: '{name}/sequences.fasta.gz'
    output: 'sequences/{name}.fa.gz'
    threads: 2
    shell: 'zcat {input} | tr U T | gzip -c - > {output}'

rule make_minimap2_index:
    input: 'refs/{name}.fa.gz'
    output: 'refs/{name}.mmidx'
    shell: 'zcat {input} | minimap2 -H -k 13 -d {output} /dev/stdin'

rule map_to_controls:
    input: seq='sequences/{name}.fa.gz', idx='refs/controls.mmidx'
    output: 'alignments/{name}-controls.bam'
    threads: 40
    shell: 'minimap2 -a --cs=long -t {threads} -k 13 -H {input.idx} {input.seq} | \
            samtools view -@ 8 -b -o {output} /dev/stdin'

rule map_to_transcriptome:
    input:
        seq='sequences/{name}.fa.gz',
        idx=lambda wc: REFERNCE_TRANSCRIPTOME_SEQS[wc.refsample].replace('.fa.gz', '.mmidx')
    output:
        'alignments/{{name}}-{{refsample,{0}}}.bam'.format('|'.join(REFERNCE_TRANSCRIPTOME_SEQS))
    threads: 40
    shell: 'minimap2 -a --cs=long -t {threads} -k 13 -H {input.idx} {input.seq} | \
            samtools view -@ 8 -b /dev/stdin | \
            samtools sort -@ {threads} -o {output} /dev/stdin'

rule make_reference_mapq_table:
    input: 'alignments/{name}-controls.bam'
    output: 'tables/controls-mapq-{name}.txt.gz'
    threads: 5
    shell: '(echo "mapq\treadid"; \
             samtools view -F4 {input} | cut -f1,5 | sort -k1,1 -k2,2rn | \
             awk -F\'\t\' \'BEGIN {{ OFS="\\t"; }} {{ print $2, $1; }}\' | \
             uniq -f1) | gzip -c - > {output}'

rule index_bam:
    input: 'alignments/{name}.bam'
    output: 'alignments/{name}.bam.bai'
    shell: 'samtools index {input}'
